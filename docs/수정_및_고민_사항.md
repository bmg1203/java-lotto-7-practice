## 고민사항

**고민**
* TDD 방식으로 로또를 구현하고자 하는데, 커밋을 어떤 식으로 해야될지 모르겠음. **실패하는 테스트, 성공하는 테스트, 리팩토링 모두 나눠서 커밋을 찍어야할까?**

**분석**
* 실패하는 테스트, 성공하는 테스트, 리팩토링 모두 따로 커밋을 하여 과정을 명확히 하고 싶음. 하지만 기능 단위로 커밋하라는 요구 사항이 있었기에 요구 사항을 따르는 것이 맞는 것 같음.  

**해결**
* 구현한 기능, 실패하는 테스트, 성공한 테스트, 리팩토링을 하나로 묶어 커밋한다

----

## 고민사항

**고민**
* 2주 차 코드를 다시 한번 리뷰하면서 문제점을 찾았음. -> CarName과 같이 원시값 포장한 객체의 경우 검증 로직을 생성자 안에 정의하였음. 생성자의 책임은 객체를 초기화 하는 것인데, 검증 로직에 대한 책임도 가지고 있다는 생각이 들었음.

**분석**
* 검증 로직에 대한 책임을 가지면서, 동시에 해당 객체를 만들어 낼 수 있는 메서드가 필요하다고 생각 -> 정적 팩토리 메서드

**해결**
* 검증 로직에 대한 책임을 가지는 생성자의 경우, 정적 팩토리 메서드를 이용함. 

----

## 고민사항

**고민**
* indent 2를 지키기 위해, try - catch 문을 쓰지 않고 어떻게 문자열인지 검증할 수 있을까?? : 문자를 숫자로 변환하는 로직

**분석**
* 1주 차 때, 공부했던 정규식을 이용하면 손쉽게 검증 할 수 있을 것 같음.

**해결**
* ``^[1-9]\d*$`` 해당 값을 이용해 문자, 음수, 0 값을 판별할 수 있음. (Console.readLine()을 통해 음수를 입력받으면, ``-``는 문자 취급되기 때문.)

----

## 고민사항

**고민**
* 2주 차 코드를 분석해보니, 같은 예외 메세지를 두 클래스에 적용한 점이 보였음. 

**분석**
* 예외 메세지를 공통으로 처리하면 해당 문제점을 처리하고 메모리를 효율적으로 관리할 수 있을 것 같음.
* 프로그램 요구사항에 enum을 이용하라 하였으니, 사용하면 될 듯 함.

**해결**
* 예외 메시지만 처리하는 enum을 만든다.
-----

## 고민사항

**고민**
* 예외처리 진행 시, 케이스 별로 엄청 세세하게 나누는 것이 좋을까?

**분석**
* 입력 값에 따라 수많은 예외 상황이 발생함 -> 이 수많은 상황을 세세하게 나누는 것이 중요할까? 
* 예외 상황이 발생할 수 있는 상황은 모두 예외처리 하는 것은 좋지만 묶을 수 있는건 같이 묶어서 예외처리 하는 것이 효율적이라고 생각함.(음수, 0, 문자 들어오는 경우는 한 번에 묶어서 처리는 것처럼) -> 근데 또 세세하게 처리하면 사용자에게 확실한 예외 처리를 반환할 수 있어서 좋은 것 같기도 함.

**해결**
* 코드 리뷰를 통해 사람들의 의견을 들어보며 상황마다 판단할 수 있는 기준을 세워야 할 것 같음.

---

## 고민사항

**고민**
* 로또 역시 자동차 경주 처럼 랜덤 넘버 숫자 반환하는 책임을 외부에서 두어야 할까?

**분석**
* 테스트 상황을 고려해보면, 인터페이스를 통해 외부에서 반환하는 것이 맞음 -> 내부에 랜덤 넘버 로직을 구현하면 테스트 시 로또 값 확인이 불가능함.

**해결**
* 인터페이스를 통해 랜덤 넘버에 책임을 가지는 객체 구현 / 로또 생성할 떄, 외부에서 랜덤 객체 주입받아서 사용해야 함.

---

## 고민사항

**고민**
* 검증 로직을 짤 때, for문을 사용한 후 if 를 통해 걸러내야 한다면 indent 2 이내로 맞추라는 조건을 어떤 식으로 지킬 수 있을까?
~~~
private void validateNumberRange(List<Integer> numbers) {
        for (int number : numbers) {
            if (number < 1 || number > 45) {
                throw new CustomException(CustomErrorCode.EXCEPTION_LOTTO_RANGE);
            }
        }
    }
~~~

**분석**
* 한 줄에 한 번에 집약할 수 있는 로직을 사용하면 됌 -> 스트림 메서드 이용

**해결**
* 스트림 메서드 이용

---

## 고민사항

**고민**
* LottoNumberGenerator 클래스에서 숫자 정렬에 대한 책임도 가지는게 맞을까? 

**분석**
* LottoNumberGenerator 는 CreateRandomNumbers 를 상속받고 있음.
* CreateRandomNumbers 의 책임은 랜덤 숫자를 생성하는 것.
* 따라서, LottoNumberGenerator는 랜덤 숫자를 생성하면서 Lotto에 맞는 숫자를 생성하면 됌. -> 정렬해서 같이 보내는 거에 책임이 있다고 판단.

**해결**
~~~
@Override
    public List<Integer> getRandomNumbers() {
        List<Integer> lottoNumber = Randoms.pickUniqueNumbersInRange(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER, LOTTO_SIZE);
        Collections.sort(lottoNumber);

        return lottoNumber;
    }
~~~
* 해당 로직처럼 정렬하여 보낸다.

---

## 고민사항

**고민**
* LottoNumberGenerator 구현 시, 검증 로직도 함께 짜야 할까? -> 이미 Lotto 클래스에 랜덤 숫자에 대한 검증 로직이 있는데, 필요없지 않을까?

**분석**
* LottoNumberGenerator는 랜덤 숫자를 반환하는 객체임. -> 검증로직이 필요하다고 생각
* 하지만 이 랜덤 숫자를 반환 받는 Lotto 클래스에서 다양한 예외 상황을 처리하였음.

**해결**
* 따라서, 검증 로직은 구현하지 않고(중복된다고 생각), 제대로 값을 반환하는지 테스트 진행.

---

## 고민사항

**고민**
* 출력 기능을 구현하기 위해, getter 지양하면서 어떤식으로 값을 받아와야 할 지 고민이 된다.

**분석**
* getter 와 setter 사용을 지양하라는 이유는 무엇일까? -> 원본 그대로의 값을 가져다 썼을 떄, 객체가 오염될 수 있음
* 이를 방지하려면 어떻게 해야할까? -> 방어적 복사 사용해야함
* 2주 차 때, 이를 적용하지 않은 것이 생각남.

**해결**
* 방어적 복사를 사용하여 객체 반환을 진행한다.
---

## 고민사항

**고민**
* Lottos 로또 생성 테스트 시, 어떤식으로 테스트 해야할까?

**분석**
* Lottos 에는 Lotto 리스트가 담김 -> equals 와 hasCode 를 오버라이드 하여 정확하게 비교해야 할까?
* Lotto 테스트에서 이미 정확한 값 검증 테스트와 하나의 로또에 번호가 몇 개 인지 테스트 하였음 -> 따라서, Lottos 에서는 리스트 사이즈만 테스트 하면 될 듯

**해결**
* Lottos 로또 생성 테스트 시, 리스트 사이즈만 비교하는 형식으로 테스트를 진행한다.(리스트에 어떤 값이 담겼는지, 로또 번호가 몇 개인지 테스트 하면 Lotto 의 테스트와 중복 된다)

-----
## 고민사항

**고민**
* 쉼표 구분자가 아닌 다른 구분자가 포함된 경우, 어떤 경우가 올 수 있을까? [예외처리]

**분석**
* 사용자가 입력하였을 떄, 보통 쉼표 옆의 온점(.)이나 슬래시(/)를 잘못 입력하여 오류가 날 것 같음.

**해결**
* 온점과 슬래시에 한하여, 구분자 입력이 잘못된 경우로 예외처리를 진행한다.

----

## 고민사항

**고민**
* LottoNumberParser 와 WinningNumber 객체를 따로 두어야 할까?

**분석**
* LottoNumberParser 의 책임은 구분자에 따라 , 로또 번호를 나누고 검증하는 것에 책임이 있음.
* 따라서, 객체를 분리한다면 WinningNumber 객체는 당첨 번호만 관리하면 됌.
* 또한, 분리하면 LottoNumberParser 재사용 가능

**해결**
* LottoNumberParser 와 WinningNumber 객체를 분리한다. 

----

## 고민사항

**고민**
* Number를 원시값 포장 하였는데, Lotto 에 있는 숫자 하나 하나 원시값 포장하는게 좋을까?

**분석**
* 원시값 포장 하여 ``List<Number>`` 형식으로 만들어 Lotto를 관리하면, 객체 지향 생활 체조 원칙을 지킬 수 있음. -> 예외처리 로직도 덜어내고, 일급컬렉션 형태 만들 수 있음
* 객체 지향 생활 체조 원칙에 따라 원시 값 포장 진행.

**해결**
* ```List<Number>``` 로 원시값 포장 한다.
----

## 수정사항 

**문제점**
* Number 클래스 생성에 따라, Lotto 클래스의 필드를 ``List<Number>`` 형식으로 만들면, 일급 컬렉션을 유지하고 객체 지향 생활 체조 원칙을 지킬 수 있다는 것을 알았음.

**분석**
* 외부에서 주입받는 값을 Number 로 포장하면 ``List<Number>`` 형식의 필드 값을 가질 수 있음.

**해결**
~~~
public Lotto(List<Integer> numbers) {
        validateLength(numbers);
        validateDuplicate(numbers);
        this.numbers = createLotto(numbers);
    }

private List<Number> createLotto(List<Integer> numbers) {
        List<Number> lottoNumber = new ArrayList<>();

        for(int number : numbers) {
            lottoNumber.add(Number.from(number));
        }

        return lottoNumber;
    }
~~~
* Lotto 클래스를 해당 형식처럼 수정함.

~~~
public static Number from(int number) {
        validateNumberRange(number);
        return new Number(number);
    }
~~~
* Number 클래스의 경우, int 값을 매개변수로 가지는 경우만 오버라이딩하여 값 범위 검증만 할 수 있도록 함. 

---

## 수정사항

**문제점**
* ~~WinningNumbers 객체를 관리할 필요가 없다는 사실을 알았음 -> 왜냐하면 이미 로또 클래스로 당첨 번호를 생성할 수 있고, 해당 클래스에 중복 처리나 로또 넘버 길이에 관한 예외 처리 기능이 다 들어가 있음.~~

**분석**
* ~~WinningNumbers 대신 Lotto 클래스로 당첨 번호 로직 관리~~

**해결**
* ~~WinningNumbers 클래스 삭제~~

---

## 고민사항

**문제점**
* 당첨 번호를 관리하는 책임이 Lottos 에 있을까? 아니면 책임을 분리해야 할까?

**분석**
* Lottos가 Lotto의 상태와 행위를 관리함. -> 그렇다면 당첨 번호를 맞추는 것에 책임이 있을까? 
* 아니라고 생각함. 왜냐하면 Lottos 의 주된 역할은 Lotto 의 컬렉션 관리임. 따라서 따로 작성 필요.

**해결**
* LottoRank 클래스 생성

----
## 고민사항

**문제점**
* 로또 당첨 로직을 어떻게 구현해야 할까?

**분석**
* 당첨 번호는 7자리이고, 로또 번호는 6자리임. (당첨 번호의 마지막은 보너스 넘버)
* 보너스 넘버이면서 5개 맞을 경우만 특수한 경우.
* 5개 맞은 로또가 마지막 넘버를 포함하면 보너스 볼 일치로 빠지도록 구현.

**해결**
* LottoRanks 를 구현하여 해당 로직에 따라, LottoRank 를 만들어 냄.

----

## 고민사항

**문제점**
* 로또 당첨 로직을 구현하다 보니, WinningLotto 객체를 만들어, 책임을 분리해야 함을 느꼈음.

**분석**
* 보너스 넘버가 일치하는지 로직을 구현해야 하는데, 해당 로직을 Lotto 객체에 두는 것은 책임에 어긋남.

**해결**
* WinningLotto 객체 생성.

---

## 고민사항

**문제점**
* WinningLotto 객체를 구현하니, Lotto 클래스와 많은 로직이 겹친다는 것을 알았음.

**분석**
* 확장성을 높이기 위해 추상 클래스를 구현할 필요 있음 -> 공통된 메서드를 너무 많이 공유함 따라서 인터페이스보다는 추상 클래스가 났다고 판단.

**해결**
* 로또 추상클래스 구현

**BasicLotto**
~~~
public abstract class BasicLotto
~~~


**Lotto**
~~~
public class Lotto extends BasicLotto {
    
    public Lotto(List<Integer> numbers) {
        super(numbers);
    }
}
~~~

**WinningLotto**
~~~
public class WinningLotto extends BasicLotto {

    public WinningLotto(List<Integer> winningLottoNumber) {
        super(winningLottoNumber);
    }

    public boolean isBonusNumber(List<Number> lotto) {
        return lotto.contains(numbers.getLast());
    }

    public void addBonusNumber(Number bonusNumbers) {
        validateBonusNumberDuplicate(bonusNumbers);
        numbers.add(bonusNumbers);
    }

    private void validateBonusNumberDuplicate(Number bonusNumber) {
        if (numbers.contains(bonusNumber)) {
            throw new CustomException(CustomErrorCode.EXCEPTION_DUPLICATED_LOTTO_NUMBER);
        }
    }
}
~~~

---

## 고민사항

**문제점**
* 당첨금으로 수익률을 계산하는 책임은 어디에 두는게 적합할까?

**분석**
* LottoRanks 클래스는 LottoRank 를 관리함 -> LottoRank 가 가지고 있는 것은 일치 개수와 당첨 가격 -> 따라서 LottoRanks 는 수익률과 당첨금 총 합을 제공할 수 있음.
* 정보를 제공할 수 있는 것이지, 출력을 내기 위해 알맞은 형태로 변환하기 위해서는, 새로운 객체가 책임을 지는게 맞음.

**해결**
* LottoRanks 가 정보 제공에 대한 책임을 가지고 있기에, 필요한 정보 제공 로직은 LottoRanks에 구현한다.
* 나머지 출력에 필요한 로직은 따로 객체를 생성해서 구현한다.

---

## 고민사항

**문제점**
* 출력할 때, 정렬된 상태에서 해야하는데 어떤식으로 하는게 좋을까?

**분석**
* statistics 클래스에서 정렬하는 메서드 추가하는 것이 책임에 알맞아 보임
* Map 자료구조 형태를 사용하는 것이 좋아보임.  - Map<LottoPrice, 당첨된 개수> 형태
* 왜냐하면 LottoPrice 를 통해 일치하는 개수인 3,4,5,5,6 값과 그에 해당하는 가격을 뽑아낼 수 있음
* 그리고 당첨된 개수를 이에 맞게 매핑해주면 출력 가능
* 수익률 메서드도 작성해야함
* 천원 단위로 돈을 끊는 메서드도 구현 필요

**해결**
* LottoRanks 가 정보 제공에 대한 책임을 가지고 있기에, 필요한 정보 제공 로직은 LottoRanks에 구현한다.
* 나머지 출력에 필요한 로직은 따로 객체를 생성해서 구현한다.

----

## 수정사항

**문제점**
* 개행시, ```\n ```이스케이프 문자는 오류를 발생시킨다는 것을 알았음

**해결**
* ``System.lineSeparator()`` 사용하여 해결

----
## 수정사항

**문제점**
* Basic 로또를 추상클래스로 구현하여 Lotto와 WinningLotto를 구현하였지만, 문제 조건에 따라, 주어진 Lotto 클래스를 사용하기 위해 다시 재수정 할 필요 있음.

**해결**
* Lotto 클래스와 WinningLotto 클래스 나누어 작성

----
## 수정사항

**문제점**
* 현재 LottoNumberParser 클래스 로직들이 캡슐화가 하나도 안되어있음.

**해결**
* LottoNumberParser 클래스 로직 캡슐화 진행.

----

