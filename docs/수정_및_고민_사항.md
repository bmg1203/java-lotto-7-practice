## 고민사항

**고민**
* TDD 방식으로 로또를 구현하고자 하는데, 커밋을 어떤 식으로 해야될지 모르겠음. **실패하는 테스트, 성공하는 테스트, 리팩토링 모두 나눠서 커밋을 찍어야할까?**

**분석**
* 실패하는 테스트, 성공하는 테스트, 리팩토링 모두 따로 커밋을 하여 과정을 명확히 하고 싶음. 하지만 기능 단위로 커밋하라는 요구 사항이 있었기에 요구 사항을 따르는 것이 맞는 것 같음.  

**해결**
* 구현한 기능, 실패하는 테스트, 성공한 테스트, 리팩토링을 하나로 묶어 커밋한다

----

## 고민사항

**고민**
* 2주 차 코드를 다시 한번 리뷰하면서 문제점을 찾았음. -> CarName과 같이 원시값 포장한 객체의 경우 검증 로직을 생성자 안에 정의하였음. 생성자의 책임은 객체를 초기화 하는 것인데, 검증 로직에 대한 책임도 가지고 있다는 생각이 들었음.

**분석**
* 검증 로직에 대한 책임을 가지면서, 동시에 해당 객체를 만들어 낼 수 있는 메서드가 필요하다고 생각 -> 정적 팩토리 메서드

**해결**
* 검증 로직에 대한 책임을 가지는 생성자의 경우, 정적 팩토리 메서드를 이용함. 

----

## 고민사항

**고민**
* indent 2를 지키기 위해, try - catch 문을 쓰지 않고 어떻게 문자열인지 검증할 수 있을까?? : 문자를 숫자로 변환하는 로직

**분석**
* 1주 차 때, 공부했던 정규식을 이용하면 손쉽게 검증 할 수 있을 것 같음.

**해결**
* ``^[1-9]\d*$`` 해당 값을 이용해 문자, 음수, 0 값을 판별할 수 있음. (Console.readLine()을 통해 음수를 입력받으면, ``-``는 문자 취급되기 때문.)

----

## 고민사항

**고민**
* 2주 차 코드를 분석해보니, 같은 예외 메세지를 두 클래스에 적용한 점이 보였음. 

**분석**
* 예외 메세지를 공통으로 처리하면 해당 문제점을 처리하고 메모리를 효율적으로 관리할 수 있을 것 같음.
* 프로그램 요구사항에 enum을 이용하라 하였으니, 사용하면 될 듯 함.

**해결**
* 예외 메시지만 처리하는 enum을 만든다.
-----

## 고민사항

**고민**
* 예외처리 진행 시, 케이스 별로 엄청 세세하게 나누는 것이 좋을까?

**분석**
* 입력 값에 따라 수많은 예외 상황이 발생함 -> 이 수많은 상황을 세세하게 나누는 것이 중요할까? 
* 예외 상황이 발생할 수 있는 상황은 모두 예외처리 하는 것은 좋지만 묶을 수 있는건 같이 묶어서 예외처리 하는 것이 효율적이라고 생각함.(음수, 0, 문자 들어오는 경우는 한 번에 묶어서 처리는 것처럼) -> 근데 또 세세하게 처리하면 사용자에게 확실한 예외 처리를 반환할 수 있어서 좋은 것 같기도 함.

**해결**
* 코드 리뷰를 통해 사람들의 의견을 들어보며 상황마다 판단할 수 있는 기준을 세워야 할 것 같음.

---

## 고민사항

**고민**
* 로또 역시 자동차 경주 처럼 랜덤 넘버 숫자 반환하는 책임을 외부에서 두어야 할까?

**분석**
* 테스트 상황을 고려해보면, 인터페이스를 통해 외부에서 반환하는 것이 맞음 -> 내부에 랜덤 넘버 로직을 구현하면 테스트 시 로또 값 확인이 불가능함.

**해결**
* 인터페이스를 통해 랜덤 넘버에 책임을 가지는 객체 구현 / 로또 생성할 떄, 외부에서 랜덤 객체 주입받아서 사용해야 함.

---

## 고민사항

**고민**
* 검증 로직을 짤 때, for문을 사용한 후 if 를 통해 걸러내야 한다면 indent 2 이내로 맞추라는 조건을 어떤 식으로 지킬 수 있을까?
~~~
private void validateNumberRange(List<Integer> numbers) {
        for (int number : numbers) {
            if (number < 1 || number > 45) {
                throw new CustomException(CustomErrorCode.EXCEPTION_LOTTO_RANGE);
            }
        }
    }
~~~

**분석**
* 한 줄에 한 번에 집약할 수 있는 로직을 사용하면 됌 -> 스트림 메서드 이용

**해결**
* 스트림 메서드 이용

---

## 고민사항

**고민**
* LottoNumberGenerator 클래스에서 숫자 정렬에 대한 책임도 가지는게 맞을까? 

**분석**
* LottoNumberGenerator 는 CreateRandomNumbers 를 상속받고 있음.
* CreateRandomNumbers 의 책임은 랜덤 숫자를 생성하는 것.
* 따라서, LottoNumberGenerator는 랜덤 숫자를 생성하면서 Lotto에 맞는 숫자를 생성하면 됌. -> 정렬해서 같이 보내는 거에 책임이 있다고 판단.

**해결**
~~~
@Override
    public List<Integer> getRandomNumbers() {
        List<Integer> lottoNumber = Randoms.pickUniqueNumbersInRange(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER, LOTTO_SIZE);
        Collections.sort(lottoNumber);

        return lottoNumber;
    }
~~~
* 해당 로직처럼 정렬하여 보낸다.

---

## 고민사항

**고민**
* LottoNumberGenerator 구현 시, 검증 로직도 함께 짜야 할까? -> 이미 Lotto 클래스에 랜덤 숫자에 대한 검증 로직이 있는데, 필요없지 않을까?

**분석**
* LottoNumberGenerator는 랜덤 숫자를 반환하는 객체임. -> 검증로직이 필요하다고 생각
* 하지만 이 랜덤 숫자를 반환 받는 Lotto 클래스에서 다양한 예외 상황을 처리하였음.

**해결**
* 따라서, 검증 로직은 구현하지 않고(중복된다고 생각), 제대로 값을 반환하는지 테스트 진행.

---

## 고민사항

**고민**
* 출력 기능을 구현하기 위해, getter 지양하면서 어떤식으로 값을 받아와야 할 지 고민이 된다.

**분석**
* getter 와 setter 사용을 지양하라는 이유는 무엇일까? -> 원본 그대로의 값을 가져다 썼을 떄, 객체가 오염될 수 있음
* 이를 방지하려면 어떻게 해야할까? -> 방어적 복사 사용해야함
* 2주 차 때, 이를 적용하지 않은 것이 생각남.

**해결**
* 방어적 복사를 사용하여 객체 반환을 진행한다.
---

## 고민사항

**고민**
* Lottos 로또 생성 테스트 시, 어떤식으로 테스트 해야할까?

**분석**
* Lottos 에는 Lotto 리스트가 담김 -> equals 와 hasCode 를 오버라이드 하여 정확하게 비교해야 할까?
* Lotto 테스트에서 이미 정확한 값 검증 테스트와 하나의 로또에 번호가 몇 개 인지 테스트 하였음 -> 따라서, Lottos 에서는 리스트 사이즈만 테스트 하면 될 듯

**해결**
* Lottos 로또 생성 테스트 시, 리스트 사이즈만 비교하는 형식으로 테스트를 진행한다.(리스트에 어떤 값이 담겼는지, 로또 번호가 몇 개인지 테스트 하면 Lotto 의 테스트와 중복 된다)

-----
## 고민사항

**고민**
* 쉼표 구분자가 아닌 다른 구분자가 포함된 경우, 어떤 경우가 올 수 있을까? [예외처리]

**분석**
* 사용자가 입력하였을 떄, 보통 쉼표 옆의 온점(.)이나 슬래시(/)를 잘못 입력하여 오류가 날 것 같음.

**해결**
* 온점과 슬래시에 한하여, 구분자 입력이 잘못된 경우로 예외처리를 진행한다.

----

## 고민사항

**고민**
* LottoNumberParser 와 WinningNumber 객체를 따로 두어야 할까?

**분석**
* LottoNumberParser 의 책임은 구분자에 따라 , 로또 번호를 나누고 검증하는 것에 책임이 있음.
* 따라서, 객체를 분리한다면 WinningNumber 객체는 당첨 번호만 관리하면 됌.
* 또한, 분리하면 LottoNumberParser 재사용 가능

**해결**
* LottoNumberParser 와 WinningNumber 객체를 분리한다. 

----

