# 방어적 복사

## 방어적 복사에 대해 학습한 이유

------
* 우리가 왜 getter 사용을 지양해야 하는지부터 알아야 합니다. 원본 데이터를 그냥 반환할 경우, 외부에서 직접 수정이 가능해져 데이터를 오염시킬 수 있습니다. 
* 저는 2주 차 때, getter를 왜 지양해야 하는지 몰라서, 그냥 사용했던 기억이 납니다. 오늘 학습을 통해 확실히 배우고 사용할 것입니다.


## 방어적 복사란 무엇인가?

------
방어적 복사란 객체의 내부 데이터를 보호하기 위해 원본이 아닌 복사본은 반환하는 것입니다.

해당 과정을 통해 외부에서 값을 변경하여도 내부의 정보는 변하지 않습니다.

## 방어적 복사를 사용하는 이유

------
제가 방어적 복사를 학습한 이유와 거의 비슷합니다.

* 외부에서 원본 데이터를 직접적으로 조작할 수 없게 하여, 데이터의 무결성을 유지할 수 있습니다. 이에 따라, 사용자는 값을 안전하게 사용할 수 있습니다.

## 방어적 복사는 깊은 복사가 아니다

-------
방어적 복사가 깊은 복사가 아니라는 점은 매우 중요합니다.

* 방어적 복사의 경우 복사본을 만들었어도, 내부의 데이터 주소는 원본과 공유하고 있습니다. -> 따라서, 원본의 내부 요소를 바꾸면 복사본도 바뀌게 됩니다.

## Unmodifiable Collection

------
Unmodifiable Collection 을 이용할 경우, 외부에서 값을 변경 시, 예외 처리가 일어나기 때문에 안전하게 보장할 수 있습니다.

unmodifiableList() 메서드를 통해 리턴되는 리스트는 읽기 용도로만 사용할 수 있으며, set(), add(), addAll() 등의 리스트에 변경을 가하는 메서드를 호출하면 ``UnsupportedOperationException`` 이 발생합니다.

다만, Unmodifiable Collection 역시 원본의 데이터가 변경되면, 제공되는 데이터의 값도 변경됩니다.

------
Ref) https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/
