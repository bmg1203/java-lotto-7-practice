# 고민했던 점들

# 1. MVC 패턴에서 뷰 와 모델 간의 의존, 컨트롤러

- MVC 구조로 과제를 진행하던 중, 한 가지 의문이 들었습니다. 뷰가 모델을 직접 받아 `getter`를 통해 화면에 데이터를 출력하는 구조를 설계했었는데, 이 방식을 사용하면 뷰가 모델을 변경할 수 있는 권한을
  얻게 되므로 구조적으로 올바르지 않다는 생각이 들었습니다.
- 이러한 의문을 계기로, 제가 MVC 패턴에 대해 제대로 알고 있는지 다시 확인하고자 공부를 시작하게 되었습니다.
- 그러던 중, 유튜브에서 '제리의 MVC 패턴'이라는 제목의 영상을 보게 되었는데, 해당 영상에서는 뷰가 모델에 직접적으로 의존해야 한다고 설명하고 있었습니다.
- 하지만, 다른 블로그 포스팅에서는 뷰가 모델에 의존해서는 안 된다고 주장하고 있었습니다.
- 점점 혼란스러워진 저는 이 주제를 두고 주변 지인들과 토론을 하게 되었고, 토론은 크게 두 가지 의견으로 좁혀졌습니다.

- **의견 1**: 뷰는 모델을 매개변수로 받아 데이터를 출력하되, 모델을 수정하지 않으면 괜찮다.
- **의견 2**: 뷰는 모델을 매개변수로 받으면 안 되고, 필요한 데이터만 담긴 객체를 매개변수로 받아 사용해야 한다.

- 이 논의를 통해, 저는 뷰와 모델 간의 결합을 최소화하기 위해 어떤 방식을 선택하는 것이 좋을지 고민해볼 수 있었습니다.
- 저는 뷰가 모델에 직접적으로 의존하지 않도록 구조를 변경했습니다.
- 뷰가 모델의 데이터를 출력하기 위해서는 `getter`가 필수적으로 필요한데, 만약 모델에서 다른 목적으로 `getter`를 사용할 필요가 없다면, 해당 `getter`는 오직 뷰를 위해 존재하게 됩니다. 이런
  상황이
  발생하다면, 모델이 뷰에 간접적으로 의존하는 결과를 초래할 수 있다고 판단했기 때문입니다.

- 이 의사결정을 코드로 반영하기 위해 뷰에 출력할 데이터를 담기 위한 여러 개의 `Response` 클래스를 만들었습니다.
- 하지만, `Response`클래스를 초기화하기 위해 모델에서 데이터를 추출하는 역할을 누가 담당해야 하는가에 대한 고민이 들었습니다.

- **방법 1 : 컨트롤러가 담당**
    - 만약 컨트롤러가 이 역할을 맡게 된다면, `Response`객체가 많아질수록 컨트롤러의 책임이 지나치게 커지고 복잡해질 것 같았습니다.
- **방법 2 : `Response`가 담당**
    - `Response`클래스에서 모델을 통해 스스로를 초기화하도록 하면, 뷰패키지 내에서 모델을 `import`하는 상황이 생겨 찜찜함이 남았습니다.

- 결과적으로, 컨트롤러의 책임을 줄이기 위해 `Response`클래스가 모델에서 반환된 결과를 받아 스스로를 초기화하는 방식을 선택했습니다. 이로 인해 컨트롤러가 너무 많은 책임을 지지 않게 되었고,
  `Response`가 모델을 직접적으로 저장하지 않기에 최소한의 의존성을 분리할 수 있었습니다.

# 2. 캡슐화와 테스트

- 다음과 같은 상황이 있었습니다.

1. `LottoNumber`는 로또 번호의 VO 로, 로또 번호인 `int` 를 저장합니다.
2. `LottoNumber`는 생성 시 검증을 위해 `MIN_NUMBER` 와 `MAX_NUMBER` 를 상수 필드로 가집니다.
3. `LottoNumber`는 생성 시, 매개변수로 받은 숫자가 `MIN_NUMBER` 와 `MAX_NUMBER` 사이의 값인지 검증을 수행합니다.

- 저는 객체의 캡슐화를 위해 해당 상수들을 `private static final` 로 선언했습니다.
- 하지만, 테스트 시 문제가 발생했습니다. `LottoNumber` 객체를 생성할 때, 입력 값이 `MIN_NUMBER와` `MAX_NUMBER` 사이에 있는지 확인하기 위해 테스트 코드에서도 이 상수들이
  필요했습니다.
  잘못된 값에 대한 검증이 제대로 이루어지는지를 판단하려면 상수 값을 참조해야 했지만, `MIN_NUMBER와` `MAX_NUMBER는` `private`으로 선언되어 있어 테스트 코드에서 접근할 수 없었습니다.

- 이 문제를 해결하기 위해 두 가지 방법을 생각했습니다.

- 방법 1 : 상수를 `public`으로 변경
    - 장점 : 유지보수가 쉽습니다. `LottoNumber` 의 상수가 변경되도 테스트 코드는 성공할 것입니다.
    - 단점 : 캡슐화가 제대로 되지 않습니다. 현재 `LottoNumber` 의 상수를 외부에 노출해야 하는 이유가 전혀 없지만, 테스트를 위해 `public` 으로 변경하게 되기 때문입니다.

- 방법2: 동일한 상수를 테스트 코드 내부에 선언
    - 장점 : 캡슐화를 지킬 수 있습니다.
    - 단점 : 유지보수가 힘듭니다. `LottoNumber` 의 `MIN_NUMBER` 가 `10`으로 바뀌면 테스트 코드 내의 상수값도 변경해야 하기 때문입니다.

- 저는 테스트 클래스 안에 동일한 `MIN_NUMBER와` `MAX_NUMBER` 상수를 다시 선언하는 방법을 선택했습니다.
- 테스트 코드로 인해 기존 코드의 캡슐화가 깨지게 되면 객체지향적인 코드를 작성할 수 없다고 판단했고, 항상 실행을 보장하는 테스트 코드가 독립적으로 존재해야 프로그램의 신뢰성을 확보할 수 있다고 판단했기
  때문입니다.

# 3. 잘못된 값을 입력한 경우 재시도를 어떻게 해야 할까?

- 사용자가 잘못된 값을 입력하면 해당 작업을 재시도하게 구현했어야 했습니다.
- 이 방식을 구현하기 위해 가장 처음 생각한 방식은 try-catch 를 사용해 예외를 catch 하는 방식이었습니다.

- 하지만, 이 방식에는 세 가지 문제점이 있었습니다.

- ### 1. 특정 Exception 만을 catch 해야 합니다.
    - `RuntimeException` 처럼 광범위한 `Exception` 을 `catch` 해 계속해서 재시도를 수행하면, 명시적으로 발생시킨 `Exception` 이 아닌 예상치 못한 `Exception`
      이 발생할 경우 `StackOverFlowError` 가 일어나기 때문입니다.
- ### 2. 특정 Exception 만을 catch 해야 하기 때문에, try-catch 를 사용하는 코드가 프로그램 전체에 큰 의존성을 가지게 됩니다.
    - 프로그램 전체에서 어떤 `Exception` 이 발생하는지를 전부 알아야 하기 때문입니다.
- ### 3. try-catch 코드로 인해 가독성이 좋지 않게 됩니다.
    - 계속해서 `try-catch` 코드를 사용해야 하기 때문입니다.

- 이 방식을 해결하기 위해 저는 두 가지 해결책을 생각해냈습니다.

- ### 1. 타입을 위한 `CustomException` 인터페이스를 사용
    - 명시적으로 발생시킬 예외들을 위한 예외 클래스들을 만들고, 해당 클래스들이 `CustomException` 을 `implement` 하도록 합니다. 이때, `CustomException` 은 타입으로의
      역할을 하게 됩니다.
    - `CustomException` 을 `implement` 하는 예외 클래스들은 각각 특정 예외를 상속받습니다.
    - 예를 들어, 사용자가 잘못된 금액을 입력했을 때 발생시킬 예외 클래스인 `PurchaseMoneyInvalidException` 는 `IllegalArgumentException` 을 상속받고,
      `CustomException` 을 `implement`하게 됩니다.
      ```
      public final class PurchaseMoneyInvalidException extends IllegalArgumentException implements CustomException {

        private PurchaseMoneyInvalidException(String message) {
          super(message);
        }
      }
      ```
    - 이렇게 되면, `Catch` 한 `Exception` 이 `CustomException` 의 인스턴스인지 파악할 수 있게 됩니다. 만약 `CustomExcpetion의` 인스턴스이면 재시도를 수행하고,
      아니라면 재시도를 수행하지 않습니다.
- ### 2. try-catch 대신 Supplier 와 Runnable 활용.
    - `Supplier` 와 `Runnable` 을 활용해 함수 형태로 재시도 로직을 구현할 수 있었습니다
        ```
        public static <T> T retryOnCustomException(Supplier<T> supplier) {
          try {
            return supplier.get();
          } catch (RuntimeException e) {
            handleException(e);
            return retryOnCustomException(supplier);
          }
        }
        ```