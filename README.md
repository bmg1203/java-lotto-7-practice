# ✅ [3주차] 로또 미션

안녕하세요 :)
지금 부터 제가 만든 로또 머신의 구체적인 기능 구현에 대해서 소개해드리겠습니다.

## 로또란 무엇일까?

제가 생각한 로또는 구성요소를 들고 있는 어떤 조합? 이라고 추상화 했습니다.

따라서 제가 설계한 로또의 시작은 구성 요소 `Component` 에서 시작합니다.

구성요소를 자유롭게 설정하기 위해서 `Component` 는 인터페이스로 구성되어 있습니다.

구성요소에 따라서 정체성이 천차만별로 바뀔 수 있기 때문에 기본적인 사항들만 요구합니다.

### Component

- [x]  Equals와 Hashcode 오버라이딩
- [x]  toString 오버라이딩

### Component를 구현하는 (숫자 구성요소)

- [x]  숫자는 1부터 45 사이여야 한다
- [x]  int 값이여야 한다

### 하나의 로또.

- [x]  어떤 요소든 구성요소로 가질 수 있다 ex) “ㄱ”, “ㄴ”, “ㄷ” 도 로또가 될 수 있어요 !
- [x]  구성요소가 길이 6에 맞아야 한다
- [x]  중복된 요소를 가져서는 안된다
- [x]  랜덤으로 1과 45 사이의 값으로 생성될 수 있어야 한다

### 구매된 로또들의 조건

- [x]  중복된 로또가 나와서는 안된다 (구매자가 억울하겠죠?)

## 보너스 숫자

- [x]  보너스 숫자는 정답 번호에 포함되어서는 안된다

여기까지가 기본적인 제가 만든 로또를 이해하기 위한 추상화의 기준입니다!
이제 게임 플레이어의 입장으로 가볼까요?

가장 먼저 플레이어는 입력값으로 돈을 입력합니다!
하지만 이때는 4가지 사항들이 검증이 됩니다.

- [x]  빈칸을 입력했어요!     ex) “”, “  “,  ”  “
- [x]  Integer가 아닌값을 입력했어요!     ex) “돈” , “천원” ,  “?!@@”
- [x]  하나의 로또도 구매하지 못할 만큼 적은 돈을 투입했어요!
- [x]  1000으로 나눠지지 않습니다 (거스름돈은 존재하지 않아요)

무사히 로또를 구매한 플레이어는 자신의 로또의 개수와 어떤 로또가 나왔는지 확인합니다

ex)

8개를 구매했습니다.\
[8, 21, 23, 41, 42, 43] \
[3, 5, 11, 16, 32, 38]\
[7, 11, 16, 35, 36, 44]\
[1, 8, 11, 31, 41, 42]\
[13, 14, 16, 38, 42, 45]\
[7, 11, 30, 40, 42, 43]\
[2, 13, 22, 32, 38, 45]\
[1, 3, 5, 14, 22, 45]

그리고 나서는 정답을 입력합니다..!

이때도 입력값 검증을 무사히 통과해야 합니다.

- [x]  빈칸을 입력했어요!     ex) “”, “  “,  ”  “
- [x]  허용된 구분자 콤마(”,”) 이외에 문자가 들어가 있어요!   ex) 1,2,3.4:5?6
- [x]  구분자로 시작하거나 끝나요!    ex) ,1,2,3,4,5,6   또는  ,1,2,3,4,5,6,

보너스 번호도 입력해야죠?

- [x]  빈칸을 입력했어요!     ex) “”, “  “,  ”  “
- [x]  Integer가 아닌값을 입력했어요!     ex) “돈” , “천원” ,  “?!@@”

헉? 이정도만 검증해도 괜찮을까요?

다른 로또 규칙들은요?

→ 다른 부분들은 클래스 자체가 생성됨에 있어서 검증이 거치게 됩니다!
예를 들어, 로또 숫자라는 클래스의 정체성은 1부터 45 사이에 있는 것이기 때문에 클래스에서 자체적으로 관리합니다!

이제 나름대로의 점수 시스템을 통해서 저의 결과가 공개가 됩니다.

- [x]  점수 조합을 설정할 수 있어야 한다
- [x]  점수 조합에 대한 보상을 설정할 수 있어야 한다

ex) \
당첨 통계 \
3개 일치 (5,000원) - 1개 \
4개 일치 (50,000원) - 0개 \
5개 일치 (1,500,000원) - 0개 \
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개 \
6개 일치 (2,000,000,000원) - 0개 \
총 수익률은 62.5%입니다.



이상 게임의 진행 과정이었습니다!

추가적 기능 구현 요소

- [x]  과제의 요구인 enum 사용에 따라 상수는 전부 enum으로 관리해본다.
- [x]  Interface와  상수 입력을 통해 확장성을 높인다. 인터페이스로 확장성을 높이기 위해 인터페이스의 method를 사용해서 구현한다.
- [x]  DDD 설계를 일급 객체를 기준으로 하고 외부와 소통은 Dto, 방어적 복사, 수정 불가 객체 return 등으로 구현한다.
---
# ✅ FeedBack 체크 리스트

## 1️⃣ 가독성

- [x]  작명의 의미 전달력
- [x]  의미 있는 주석 달기
- [x]  코드 포맷팅  IntelliJ IDEA: ⌥⌘L
- [x]  커밋 메시지의 feedback 적용하기 (구문 형태, 제목과 내용)
- [x]  EOF 세팅
- [x]  값 객체는 VO로 분류 (하나 뿐이어서 디렉토리 생성 생략)
- [x]  요약 설명은 Comment에 ReadMe는 꼼꼼히하고 상시 업데이트
- [x]  구현순서를 깔끔하게 하였는가

## 2️⃣ 코딩 습관

- [x]  필요하다면 싱글톤을 적용하기
- [x]  Stream 적극 활용
- [x]  Interface 적극 사용
- [x]  근거 있는 static 사용
- [x]  컬렉션 사용 API 적극 사용하기
- [x]  디버깅 적극 사용
- [x]  안쓰는 Importation 삭제
- [x] 변수명에 자료형을 쓰지 않는다
- [x] 변수명에 불용어를 넣지 않는다

## 3️⃣ 설계 중점 사항

- [x]  1급 컬렉션 사용
- [x]  참조로 추적되는 데이터형 getter 지양 → DTO 사용 (record 타입),방어적 복사 대안, 수정불가 객체 return
- [x]  구현방식에 집중해서 과제 자체에 대한 예외들을 빼먹지 말 것
- [x]  Enum으로 상수 그룹화 관리
- [x]  매서드는 한 가지 일만 처리한다
- [x]  마지막 프로그래밍 요구 사항 지켰는지 check

## 4️⃣ Test

- [x]  assertJ 를 사용하여 명확한 단위 테스트 
- [x]  test coverage check
- [x]  테스트에서 Interface를 상속받는 Mock 클래스 사용해보기
- [x]  테스트 자체에서 매서드를 만들거나 여러 기능을 사용해 중복 테스트 줄이기
- [x]  2주차 feedback 테스트 매서드 참고 자료 활용
- [x]  UI(System.out, System.in, Scanner) 로직은 제외한다 -> 굳이 사용할 필요가 없었다




