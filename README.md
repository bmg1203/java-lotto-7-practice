# **Java 로또**

## **구매 (Purchase)**

### 도메인 구성 요소
- **Money**
    - 입력받은 금액을 관리하고, 구매 가능한 로또 개수와 수익률을 계산합니다.
    - **필드**:
        - `money`: `long` - 사용자가 입력한 금액.

- **Purchase**
    - 구매한 로또를 로또 저장소에 저장하고, 각 로또의 고유 ID를 보관합니다.
    - **필드**:
        - `lottoId`: `String` - 구매한 로또의 고유 ID.
        - `money`: `Money` - 사용자가 입력한 금액.

- **PurchaseResult**
    - 구매한 로또 정보를 사용자에게 반환할 때 사용되며, 수익률과 로또 등수 정보를 포함합니다.
    - **필드**:
        - `purchase`: `Purchase` - 구매한 로또 정보.
        - `rateOfReturn`: `double` - 수익률.
        - `winningInfo`: `Map<LottoRank, Long>` - 로또 등수 정보.

## **로또 (Lotto)**

### 도메인 구성 요소
- **LottoResult** (루트)
    - 개별 로또 정보와 등수를 보관하고, 로또 등수가 평가되었는지의 상태를 유지합니다.
    - **필드**:
        - `lotto`: `Lotto` - 로또 번호 정보.
        - `lottoRank`: `LottoRank` - 로또 등수.

- **Lotto**
    - 로또 번호 정보를 저장하는 객체입니다.
    - **필드**:
        - `numbers`: `List<Integer>` - 로또 번호 목록.

- **LottoWinning**
    - 당첨 로또를 보관하는 객체입니다.
    - **필드**:
        - `lotto`: `Lotto` - 당첨된 로또 번호 정보.
        - `bonusNumber`: `Integer` - 보너스 번호.

- **LottoResults**
    - 여러 당첨 로또 정보를 보관하는 객체로, 각 `LottoResult` 객체를 리스트로 저장합니다.
    - **필드**:
        - `results`: `List<LottoResult>` - 당첨된 로또들의 결과 목록.
        - `id`: `String` - 저장 시 고유 식별 ID.

### 값 객체 (Value Object)
- **LottoRank**
    - 로또 등수 정보를 저장하는 `Enum` 타입입니다.

## **전략**

1. **검증 (Validation)**
    - 입력값 검증을 통해 유효성을 확인합니다.
        - **입력값이 null인지 확인** - `ConsoleInputHandler`에서 입력값이 null인지를 확인하여 유효한 데이터만 처리합니다.
        - **입력값 타입 확인** - `Validator`에서 입력 데이터 타입을 확인하여 올바르지 않은 타입일 경우 오류를 발생시킵니다.
        - **값 유효성 확인** - 각 도메인 객체에서 논리적 유효성을 검사하여 데이터 무결성을 보장합니다.

## **고려 사항**
1. **애그리거트 간 직접 참조를 최소화** - 느슨한 결합을 유지하여 코드의 의존성을 줄이고 유지보수성을 높였습니다.
2. **불변성을 보장** - 도메인 객체는 변경 불가능하게 설계하여 데이터 안정성을 유지합니다.
3. **Repository의 동시성 처리** - 다중 스레드 환경에서 데이터 충돌을 방지하기 위해 Repository를 동시성 고려하여 설계했습니다.
4. **Factory와 Provider 패턴 사용** - 객체 생성의 복잡성을 줄이고, 코드의 유연성과 확장성을 확보했습니다.
5. **테스트를 위한 Fake 및 Mock 활용** - 테스트 환경에서 안정적인 검증을 위해 Fake, Mock 객체를 사용하여 외부 의존성을 격리하고 테스트의 신뢰성을 높였습니다.

## **한계점**
1. **오버 엔지니어링 가능성** - DDD로 설계하면서 구현에 많은 시간이 소요되어, 실제 필요한 복잡도보다 높은 구조가 되었습니다.
2. **검증 로직의 일관성 문제** - 세부 예외 단위로 검증하기보다는 도메인 단위로 검증을 처리하였기에, 예외 처리의 효율성이 떨어짐.