# 프리코스 3주차 미션 - 로또

해당 프로그램은 사용자가 **로또를 자동으로 구입하는 상황을 시뮬레이션**합니다. 사용자가 구입금액을 입력하면 로또 번호가 자동으로 추첨되며, 입력받은 당첨 번호와 보너스 번호에 일치하는 로또 개수가 몇 개인지 확인한 후 수익률을 계산합니다.

## 로또 프로그램의 기능

- [x]  사용자로부터 입력받는 기능
    - 사용자로부터 구입금액을 입렫받는다.
    - 사용자로부터 당첨 번호를 입력받는다.
    - 사용자로부터 보너스 번호를 입력받는다.
- [x]  콘솔에 출력하는 기능
    - 구입 금액에 맞게 로또를 구입한 후 개수를 출력한다.
    - 자동으로 뽑은 로또 번호들을 출력한다.
    - 당첨 통계를 출력한다.
    - 총 수익률을 출력한다.
- [x]  입력한 구입금액으로부터 구매 가능한 로또 수량을 계산하는 기능
    - 입력받은 구입금액에서 1,000을 나눠 계산한다.
- [x]  입력한 당첨 번호를 콤마로 구분하여 파싱하는 기능
- [x]  로또 번호를 랜덤으로 뽑는 기능
    - `camp.nextstep.edu.missionutils.Randoms`의 `pickUniqueNumbersInRange()`를 활용하여 1부터 45의 값을 중복되지 않게 6개 추출한다.
- [x]  뽑은 로또 숫자 중 몇 개가 당첨되었는지 계산하는 기능
    - 당첨 번호와 일치하는 숫자의 개수를 계산한다.
    - 보너스 숫자와 일치하는 수가 있는지 계산한다.
- [x]  순위 별로 당첨된 로또의 개수가 몇 개인지 계산하는 기능
- [x]  수익률을 계산하는 기능
    - $\frac{당첨금액}{구입금액}$으로 계산한다.

## 로또 프로그램의 예외 상황

- [x]  구입 금액이 1,000원으로 나누어 떨어지지 않는 경우
- [x]  구입 금액이 숫자가 아닐 경우
- [x]  구입 금액이 0일 경우
- [x]  구입 금액이 음수이거나 소수, 혹은 int형 최대치를 넘어가는 경우
- [x]  당첨 번호나 보너스 번호가 숫자가 아닐 경우
- [x]  당첨 번호나 보너스 번호가 0일 경우
- [x]  당첨 번호나 보너스 번호가 음수이거나 소수, 혹은 int형 최대치를 넘어가는 경우
- [x]  당첨 번호와 보너스 번호 간 중복되는 수가 존재할 경우

## 요구 사항

- JDK 21 버전에서 실행 가능해야 한다.
- 프로그램 실행의 시작점은 Application의 main()이다.
- build.gradle 파일은 변경할 수 없으며, 제공된 라이브러리 이외의 외부 라이브러리는 사용하지 않는다.
- 프로그램 종료 시 System.exit()를 호출하지 않는다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다.
- 자바 코드 컨벤션을 지키면서 프로그래밍한다.
    - 블럭 들여쓰기: +4 스페이스
    - 열 제한: 120
    - 들여쓰기 지속은 최소 +8 스페이스
    - 수직 빈 줄
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- 3항 연산자를 쓰지 않는다.
- 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- JUnit 5와 AssertJ를 이용하여 정리한 기능 목록이 정상적으로 작동하는지 테스트 코드로 확인한다.
- 함수 또는 메서드의 길이가 15라인을 넘어가지 않도록 구현한다. → 메서드가 한 가지 일만 하도록 구현한다.
- else 예약어를 쓰지 않는다.
- Java Enum을 이용하여 프로그램을 구현한다.
- 구현한 기능에 대한 단위 테스트를 구현한다.

## 전 주차 피드백

- README.md를 상세히 작성한다.
- 기능 목록을 재검토한다.
- 기능 목록을 업데이트한다.
- 값을 하드 코딩하지 않는다. → 상수를 정의하여 사용하라.
- 구현 순서도 코딩 컨벤션이다. → 클래스는 상수, 멤버 변수, 메서드 순으로 작성한다.
- 변수 이름에 자료형은 사용하지 않는다.
- 한 메서드가 한 가지 기능만 담당하게 한다.
- 메서드가 한 가지 기능을 하는지 확인하는 기준을 세운다. → 한 메서드 당 15라인
- 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.
- 처음부터 큰 단위의 테스트를 만들지 않는다.

## 코드 컨벤션

- 한 메서드에 오직 한 단계의 들여쓰기(indent)만 허용
- else 예약어를 쓰지 않았는가?
- 모든 원시값과 문자열을 포장했는가?
- 콜렉션에 대해 일급 콜렉션을 적용했는가?
- 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지 않았는가?
- getter/setter 없이 구현했는가?
- 메소드의 인자 수를 제한했는가?
- 코드 한 줄에 점(.)을 하나만 허용했는가?
- 메소드가 한가지 일만 담당하도록 구현했는가?
- 클래스를 작게 유지하기 위해 노력했는가?
