# 안다고 생각했던 것들과 배운 개념들

## 1. 정적 팩토리 메서드의 올바른 사용법

### 알고 있던 개념

1. 정적 팩토리 메서드는 생성자 대신 static 매개변수를 사용하는 방식이다.

### 몰랐던 개념과 배운 개념

- 코드 리뷰 과정에서 정적 팩토리 메서드를 사용한 다른 분들의 코드를 보게 되었습니다.
- 제가 아는 바로는 정적 팩토리 메서드는 생성자를 대체할 수 있는 기능이지만, 사람들이 어떤 이유로 이를 선호하는지 궁금했습니다.
- 정적 팩토리 메서드 방식을 사용하는 이유를 모른다는 것은 제가 이 개념에 대해 정확히 알고 있지 않다는 것을 뜻했기 때문에 정적 팩토리 메서드의 장단점과 사용 이유에 대해 찾아보게 되었습니다.

**정적 팩토리 메서드**: 객체 생성의 역할을 책임지는 메서드.
**정적 팩토리 메서드를 사용하는 이유**: 해당 객체의 생성 목적과 방식을 구분지을 수 있다.
new 연산을 통해 객체를 생성하게 되면, 해당 객체의 내부 생성 로직을 알아야 하는데, 정적 팩토리 메서드를 사용하면 메서드 이름에 객체의 생성 목적을 담아 낼 수 있다.

### 정적 팩토리 메서드의 장단점

- 장점
    - 장점1 : 객체 생성 시, 내부 로직을 캡슐화시킬 수 있다.
        - 예를 들어 생성 방식에 따른 검증 로직을 팩토리 메서드 내부로 캡슐화할 수 있다.
    - 장점2 : 자식 객체를 반환할 수 있다.
        - 예를 들어, `A`의 자식 클래스인 `B`가 있을 때, `A`가 `B`의 인스턴스를 반환할 수 있다.
    - 장점3 : 객체 생성에 이름을 가질 수 있어 객체의 생성 목적을 담을 수 있다.
        - 예를 들어, `Lottos.generate()` 메서드를 통해 랜덤하게 로또를 생성한다는 의미를 담을 수 있다.

- 단점
    - 단점1 : 상속 시 오버라이드할 수 없다.
        - static 메서드는 상속이 되지 않기 때문이다.
    - 단점2 : 정적 팩토리의 수가 많아지면 코드가 늘어난다.

- 정적 팩토리 메서드에 대해 이해를 하니 어떻게 사용해야 하고 왜 사용해야 하는지 알 수 있었습니다.
- 매개변수로 필드값을 받지 않고 객체 생성 방식이 복잡한 클래스에 정적 팩토리 메서드 방식을 적용할 수 있었습니다.
- `Lotto`의 일급 컬렉션인 `Lottos`를 생성할 때, `new Lottos(…)` 을 사용하지 않고, `Lottos.generate()` 형식으로 정적 팩토리 메서드를 구현해 로또 일급 컬렉션의 내부 생성
  로직을
  캡슐화할 수 있었습니다.
- 또한, 예외를 발생시키는 로직도 캡슐화할 수 있었습니다.
- 정적 팩토리 메서드의 장점 중 하나인 `“자식 객체를 반환할 수 있다”` 를 사용해 사용자가 잘못된 값을 입력했을 때, `IllegalArgumentException` 의 자식 예외인
  `LottoNumberInvalidException` 등을 발생시킬 수 있었습니다.

## 2. `toString()` 을 오버라이드해야 하는 이유

### 알고 있던 개념

1. `toString()` 을 재정의하면 객체 출력 시, 해당 메서드에 있는 내용이 출력된다.

### 몰랐던 개념과 배운 개념

- `toString()` 이 객체 출력을 위해서 사용된다는 것은 알았지만, 왜 사용해야 하는지에 대해서는 알지 못했습니다.
- 지난 과제에서 `toString()`을 오버라이드해 출력에 사용한 분의 코드를 보며, 단순 출력을 위해 사용하기에는 확장성이 떨어질 것 같다는 생각이 들었고, 그렇다면 왜 사용하는 것인지 궁금해져 찾아보게
  되었습니다.
- `toString()` 을 사용하는 이유: 객체를 사람이 읽기 쉬운 문자열로 표현하여 디버깅 및 로깅 시 유용하게 사용하기 위함.
- `toString()` 을 재정의하지 않으면, 객체 출력 시 `“클래스명@HashCode”` 로 출력된다.

### `toString()` 오버라이드의 장단점

    - 장점 : 디버깅과 로깅에 유용하다.
        - 이 장점을 확인하기 위해 테스트 코드를 작성하며 `toString()` 이 오버라이드되지 않은 상태에서 객체를 출력해보았습니다.
        - 객체 내부 내용을 알 수 없어 불편하다는 것을 느낄 수 있었습니다.
    - 단점 : `toString()` 을 오버라이드하며 코드가 길어지고, 유지보수 리소스가 더 들어가게 된다.
        - 필드 구성이 필드명이 변경되면 `toString()` 의 코드도 수정해야 하기 때문입니다.
        - 이 문제를 해결하기 위해 `Lombok` 에서 지원하는 어노테이션을 사용하면 편합니다.

- `toString()` 을 오버라이드하며 생기는 장점이 단점보다 더 크다고 느꼈고, `@ParameterizedTest` 에서 유용하게 사용할 수 있었습니다.

## 3. 클래스 내부 상수에서 `static` 을 사용하는 이유

### 알고 있던 개념

1. 필드에 `static` 키워드를 사용하면 클래스가 메모리에 로드될 때 해당 필드가 한 번만 생성된다.
2. 필드에 `private` 키워드를 사용하면 외부에서 해당 필드에 직접적으로 접근할 수 없다.

### 몰랐던 개념과 배운 개념

- 저는 지금까지 클래스 내부에서 상수를 저장할 때, `private final` 로만 선언했습니다.
- 하지만, 코드리뷰를 통해 `private` 상수는 `private static final` 로 선언하라는 내용을 접했습니다.
- `static` 키워드를 사용하는 이유를 찾기 위해서 우선 인터넷을 끄고, 노트에 생각을 적어나갔습니다.

### 직접 생각해 본 `private` 상수에서의 `static` 사용 이유

1. `static` 으로 선언하면, 해당 값이 메모리에 한 번만 할당되어 모든 인스턴스가 공유하게 된다.
2. 그러므로, 객체가 `1000` 개가 생성되어도, 해당 객체의 상수 필드의 메모리 주소는 전부 같다.
3. `static` 을 사용하지 않으면, 객체가 `1000` 개 생성되면 해당 상수도 `1000` 개가 생성된다.

- 결론: 메모리 효율성을 위해 사용한다.

- 노트에 생각을 전부 작성한 후, 검증하기 위해 인터넷을 찾아보았고, 제가 한 생각이 맞았다는 것을 알 수 있었습니다.